package com.tunjid.composables.ui

import androidx.compose.animation.core.FiniteAnimationSpec
import androidx.compose.animation.core.spring
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.layout.ScaleFactor
import androidx.compose.ui.layout.lerp
import com.tunjid.composables.ui.Interpolator.Companion.rememberUpdatedInterpolator

/**
 * Returns a [ContentScale] that animates smoothly between the initial value this method
 * was composed with and subsequent invocations. This allows for preserving
 * visual continuity across dynamic contexts like shared elements.
 *
 * @param animationSpec The [FiniteAnimationSpec] to be used for the animation.
 * Note that changes to [animationSpec] while the animation is in progress have no effect.
 * They will only be applied on the next [ContentScale] change to preserve animation smoothness.
 */
@Composable
fun ContentScale.animate(
    animationSpec: FiniteAnimationSpec<Float> = spring(),
): ContentScale {
    val interpolation = rememberUpdatedInterpolator(
        value = this@animate,
        animationSpec = animationSpec,
        interpolatedSnapshot = { previous, current, fraction ->
            lerpedContentScale(
                start = { previous },
                stop = { current },
                fraction = { fraction },
            )
        }
    )
    return lerp(
        interpolation.previous,
        interpolation.current,
        interpolation.interpolation,
    )
}

/**
 * Linearly interpolate between two [ContentScale] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 */
@Composable
fun lerp(
    start: ContentScale,
    stop: ContentScale,
    fraction: Float,
): ContentScale {
    val updatedStart = rememberUpdatedState(start)
    val updatedStop = rememberUpdatedState(stop)
    val updatedFraction = rememberUpdatedState(fraction)
    return remember {
        lerpedContentScale(
            start = updatedStart::value,
            stop = updatedStop::value,
            fraction = updatedFraction::value,
        )
    }
}

private inline fun lerpedContentScale(
    crossinline start: () -> ContentScale,
    crossinline stop: () -> ContentScale,
    crossinline fraction: () -> Float,
) = object : ContentScale {
    override fun computeScaleFactor(
        srcSize: Size,
        dstSize: Size,
    ): ScaleFactor =
        lerp(
            start = start().computeScaleFactor(
                srcSize = srcSize,
                dstSize = dstSize,
            ),
            stop = stop().computeScaleFactor(
                srcSize = srcSize,
                dstSize = dstSize,
            ),
            fraction = fraction(),
        )
}