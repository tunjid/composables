package com.tunjid.composables.ui

import androidx.collection.MutableIntList
import androidx.compose.animation.core.AnimationSpec
import androidx.compose.animation.core.FiniteAnimationSpec
import androidx.compose.animation.core.spring
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.ui.unit.Density
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.LayoutDirection
import com.tunjid.composables.ui.Interpolator.Companion.rememberUpdatedInterpolator

/**
 * Returns a horizontal [Arrangement] that animates smoothly between the initial value this method
 * was composed with and subsequent invocations. This allows for preserving
 * visual continuity across dynamic contexts.
 *
 * @param animationSpec The [FiniteAnimationSpec] to be used for the animation.
 * Note that changes to [animationSpec] while the animation is in progress have no effect.
 * They will only be applied on the next [Arrangement] change to preserve animation smoothness.
 */
@Composable
fun Arrangement.Horizontal.animate(
    animationSpec: AnimationSpec<Float> = spring(),
): Arrangement.Horizontal {
    val interpolation = rememberUpdatedInterpolator(
        value = this@animate,
        animationSpec = animationSpec,
        interpolatedSnapshot = { previous, current, fraction ->
            lerpedHorizontalArrangement(
                start = { previous },
                stop = { current },
                fraction = { fraction },
            )
        }
    )
    return lerp(
        interpolation.previous,
        interpolation.current,
        interpolation.interpolation,
    )
}

/**
 * Returns a vertical [Arrangement] that animates smoothly between the initial value this method
 * was composed with and subsequent invocations. This allows for preserving
 * visual continuity across dynamic contexts.
 *
 * @param animationSpec The [FiniteAnimationSpec] to be used for the animation.
 * Note that changes to [animationSpec] while the animation is in progress have no effect.
 * They will only be applied on the next [Arrangement] change to preserve animation smoothness.
 */
@Composable
fun Arrangement.Vertical.animate(
    animationSpec: AnimationSpec<Float> = spring(),
): Arrangement.Vertical {
    val interpolation = rememberUpdatedInterpolator(
        value = this@animate,
        animationSpec = animationSpec,
        interpolatedSnapshot = { previous, current, fraction ->
            lerpedVerticalArrangement(
                start = { previous },
                stop = { current },
                fraction = { fraction },
            )
        }
    )
    return lerp(
        interpolation.previous,
        interpolation.current,
        interpolation.interpolation,
    )
}

/**
 * Linearly interpolate between two [Arrangement.Horizontal] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 */
@Composable
fun lerp(
    start: Arrangement.Horizontal,
    stop: Arrangement.Horizontal,
    fraction: Float,
): Arrangement.Horizontal {
    val updatedStart = rememberUpdatedState(start)
    val updatedStop = rememberUpdatedState(stop)
    val updatedFraction = rememberUpdatedState(fraction)
    return remember {
        lerpedHorizontalArrangement(
            start = updatedStart::value,
            stop = updatedStop::value,
            fraction = updatedFraction::value,
        )
    }
}

/**
 * Linearly interpolate between two [Arrangement.Vertical] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 */
@Composable
fun lerp(
    start: Arrangement.Vertical,
    stop: Arrangement.Vertical,
    fraction: Float,
): Arrangement.Vertical {
    val updatedStart = rememberUpdatedState(start)
    val updatedStop = rememberUpdatedState(stop)
    val updatedFraction = rememberUpdatedState(fraction)
    return remember {
        lerpedVerticalArrangement(
            start = updatedStart::value,
            stop = updatedStop::value,
            fraction = updatedFraction::value,
        )
    }
}

private inline fun lerpedHorizontalArrangement(
    crossinline start: () -> Arrangement.Horizontal,
    crossinline stop: () -> Arrangement.Horizontal,
    crossinline fraction: () -> Float,
) = object : Arrangement.Horizontal {
    private val array = MutableIntList()

    override val spacing: Dp
        get() = androidx.compose.ui.unit.lerp(
            start = start().spacing,
            stop = stop().spacing,
            fraction = fraction(),
        )

    override fun Density.arrange(
        totalSize: Int,
        sizes: IntArray,
        layoutDirection: LayoutDirection,
        outPositions: IntArray,
    ) = lerp(
        start = {
            with(start()) {
                arrange(totalSize, sizes, layoutDirection, outPositions)
                outPositions
            }
        },
        stop = {
            with(stop()) {
                arrange(totalSize, sizes, layoutDirection, outPositions)
                outPositions
            }
        },
        array = array,
        fraction = fraction(),
    )
}

private inline fun lerpedVerticalArrangement(
    crossinline start: () -> Arrangement.Vertical,
    crossinline stop: () -> Arrangement.Vertical,
    crossinline fraction: () -> Float,
) = object : Arrangement.Vertical {
    private val array = MutableIntList()

    override val spacing: Dp
        get() = androidx.compose.ui.unit.lerp(
            start = start().spacing,
            stop = stop().spacing,
            fraction = fraction(),
        )

    override fun Density.arrange(
        totalSize: Int,
        sizes: IntArray,
        outPositions: IntArray,
    ) = lerp(
        start = {
            with(start()) {
                arrange(totalSize, sizes, outPositions)
                outPositions
            }
        },
        stop = {
            with(stop()) {
                arrange(totalSize, sizes, outPositions)
                outPositions
            }
        },
        array = array,
        fraction = fraction(),
    )
}

private inline fun lerp(
    crossinline start: () -> IntArray,
    crossinline stop: () -> IntArray,
    array: MutableIntList,
    fraction: Float,
) {
    array.clear()
    var arrangedSizes = start()
    for (it in arrangedSizes) {
        array.add(it)
    }
    arrangedSizes = stop()
    for (i in 0..arrangedSizes.lastIndex) {
        arrangedSizes[i] = androidx.compose.ui.util.lerp(
            start = array[i],
            stop = arrangedSizes[i],
            fraction = fraction,
        )
    }
}