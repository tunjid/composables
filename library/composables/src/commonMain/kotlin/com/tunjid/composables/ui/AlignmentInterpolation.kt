package com.tunjid.composables.ui

import androidx.compose.animation.core.AnimationSpec
import androidx.compose.animation.core.FiniteAnimationSpec
import androidx.compose.animation.core.spring
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.ui.Alignment
import androidx.compose.ui.unit.lerp
import com.tunjid.composables.ui.Interpolator.Companion.rememberUpdatedInterpolator

/**
 * Returns a [Alignment] that animates smoothly between the initial value this method
 * was composed with and subsequent invocations. This allows for preserving
 * visual continuity across dynamic contexts like shared elements.
 *
 * @param animationSpec The [FiniteAnimationSpec] to be used for the animation.
 * Note that changes to [animationSpec] while the animation is in progress have no effect.
 * They will only be applied on the next [Alignment] change to preserve animation smoothness.
 */
@Composable
fun Alignment.animate(
    animationSpec: AnimationSpec<Float> = spring(),
): Alignment {
    val interpolation = rememberUpdatedInterpolator(
        value = this@animate,
        animationSpec = animationSpec,
        interpolatedSnapshot = { previous, current, fraction ->
            lerpedAlignment(
                start = { previous },
                stop = { current },
                fraction = { fraction },
            )
        }
    )
    return lerp(
        interpolation.previous,
        interpolation.current,
        interpolation.interpolation,
    )
}

/**
 * Linearly interpolate between two [Alignment] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 */
@Composable
fun lerp(
    start: Alignment,
    stop: Alignment,
    fraction: Float,
): Alignment {
    val updatedStart = rememberUpdatedState(start)
    val updatedStop = rememberUpdatedState(stop)
    val updatedFraction = rememberUpdatedState(fraction)
    return remember {
        lerpedAlignment(
            start = updatedStart::value,
            stop = updatedStop::value,
            fraction = updatedFraction::value,
        )
    }
}

private inline fun lerpedAlignment(
    crossinline start: () -> Alignment,
    crossinline stop: () -> Alignment,
    crossinline fraction: () -> Float,
) = Alignment { size, space, layoutDirection ->
    lerp(
        start = start().align(
            size = size,
            space = space,
            layoutDirection = layoutDirection,
        ),
        stop = stop().align(
            size = size,
            space = space,
            layoutDirection = layoutDirection,
        ),
        fraction = fraction(),
    )
}