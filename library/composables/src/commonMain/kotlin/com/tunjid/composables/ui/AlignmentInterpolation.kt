package com.tunjid.composables.ui

import androidx.compose.animation.core.AnimationSpec
import androidx.compose.animation.core.FiniteAnimationSpec
import androidx.compose.animation.core.animate
import androidx.compose.animation.core.spring
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.unit.lerp

/**
 * Returns a [Alignment] that animates smoothly between the initial value this method
 * was composed with and subsequent invocations. This allows for preserving
 * visual continuity across dynamic contexts like shared elements.
 *
 * @param animationSpec The [FiniteAnimationSpec] to be used for the animation.
 * Note that changes to [animationSpec] while the animation is in progress have no effect.
 * They will only be applied on the next [Alignment] change to preserve animation smoothness.
 */
@Composable
fun Alignment.animate(
    animationSpec: AnimationSpec<Float> = spring(),
): Alignment {
    val updatedAnimationSpec by rememberUpdatedState(animationSpec)
    var interpolation by remember {
        mutableFloatStateOf(1f)
    }
    var previousAlignment by remember {
        mutableStateOf(this)
    }
    val currentAlignment by remember {
        mutableStateOf(this)
    }.apply {
        if (value != this@animate) {
            previousAlignment = if (interpolation == 1f) {
                // Value has changed, trigger an animation
                value
            } else {
                // A previous animation has been interrupted. Capture the present state,
                // and restart the animation.
                lerp(
                    fraction = interpolation,
                    start = previousAlignment,
                    stop = value,
                )
            }
            // Reset the interpolation
            interpolation = 0f
        }
        // Set the current value, this will also stop any call to lerp above from recomposing
        value = this@animate
    }

    LaunchedEffect(currentAlignment) {
        animate(
            initialValue = 0f,
            targetValue = 1f,
            animationSpec = updatedAnimationSpec,
            block = { progress, _ ->
                interpolation = progress
            },
        )
    }

    return remember {
        Alignment { size, space, layoutDirection ->
            val start = previousAlignment.align(
                size = size,
                space = space,
                layoutDirection = layoutDirection,
            )
            val stop = currentAlignment.align(
                size = size,
                space = space,
                layoutDirection = layoutDirection,
            )

            if (start == stop) {
                stop
            } else {
                lerp(
                    start = start,
                    stop = stop,
                    fraction = interpolation,
                )
            }
        }
    }
}

/**
 * Linearly interpolate between two [Alignment] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 */
@Composable
fun lerp(
    start: Alignment,
    stop: Alignment,
    fraction: Float,
): Alignment {
    val updatedFraction by rememberUpdatedState(fraction)
    return remember {
        Alignment { size, space, layoutDirection ->
            lerp(
                start = start.align(
                    size = size,
                    space = space,
                    layoutDirection = layoutDirection,
                ),
                stop = stop.align(
                    size = size,
                    space = space,
                    layoutDirection = layoutDirection,
                ),
                fraction = updatedFraction,
            )
        }
    }
}